name: Build Multi-Platform

on:
  push:
    branches:
      - main
      - master
      - cadquery-ocp
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
      - master
      - cadquery-ocp
  workflow_dispatch:

env:
  PYTHON_WIN: "3.8"
  OCP_VERSION_WIN: "7.5.3"
  PYTHON_MAC: "3.9"
  OCP_VERSION_MAC: "7.7.2"
  # 锁定 PyInstaller 版本 (Win7 兼容性)
  PYINSTALLER_VERSION: "5.13.2"
  PYTHONIOENCODING: "utf-8"
  PYTHONUTF8: "1"

jobs:
  build-windows-x64:
    runs-on: windows-2019
    env:
      PYTHONIOENCODING: utf-8
      PYTHONUTF8: 1

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Miniconda
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-update-conda: true
          python-version: ${{ env.PYTHON_WIN }}
          architecture: x64
          channels: conda-forge, defaults
          channel-priority: flexible

      - name: Install Dependencies & Fix Metadata
        shell: bash -el {0}
        run: |
          echo "===== 1. Installing Conda Dependencies ====="
          conda install -y -c conda-forge \
            ocp=${{ env.OCP_VERSION_WIN }} \
            trimesh \
            "numpy<2.0"
          
          echo "===== 2. Nuke Corrupted Metadata (Deep Scan) ====="
          # 这是一个 Python 脚本，直接嵌入在 bash 中运行
          # 它会扫描所有安装包，找到那个含有 "-PKG-VERSION" 的坏文件并强制删除
          python -c "
          import sys
          import shutil
          from pathlib import Path
          
          # 定位 site-packages 目录
          site_packages = Path(sys.prefix) / 'Lib' / 'site-packages'
          print(f'Scanning site-packages: {site_packages}')
          
          if not site_packages.exists():
              print('ERROR: site-packages not found!')
              sys.exit(1)
          
          # 暴力扫描：检查每一个 dist-info 文件夹
          count = 0
          for dist_info in site_packages.glob('*.dist-info'):
              metadata_file = dist_info / 'METADATA'
              if metadata_file.exists():
                  try:
                      # 读取文件前几行
                      with open(metadata_file, 'r', encoding='utf-8', errors='ignore') as f:
                          content = f.read(1024)
                          
                      # 检查是否包含非法版本号
                      if 'Version: -PKG-VERSION' in content:
                          print(f'!!! FOUND BROKEN PACKAGE !!!')
                          print(f'   Path: {dist_info}')
                          print(f'   Action: DELETING...')
                          shutil.rmtree(dist_info, ignore_errors=True)
                          print(f'   Result: Deleted.')
                          count += 1
                  except Exception as e:
                      print(f'Warning: Could not read {dist_info}: {e}')
          
          if count == 0:
              print('Warning: No broken packages found via content scan. Trying name scan...')
              # 备用方案：按名字删除 vtk 开头的 dist-info
              for p in site_packages.glob('*vtk*.dist-info'):
                  print(f'Deleting suspect folder: {p}')
                  shutil.rmtree(p, ignore_errors=True)
          else:
              print(f'Successfully removed {count} broken metadata folders.')
          "
          
          echo "===== 3. Installing PyInstaller via Pip ====="
          # 此时坏文件已被清除，pip 应该可以正常工作了
          python -m pip install pyinstaller==${{ env.PYINSTALLER_VERSION }}
          
          echo "===== 4. Verifying Installation ====="
          python -c "from OCP.STEPCAFControl import STEPCAFControl_Reader; print('OCP import OK')"
          pyinstaller --version

      - name: Create Win7 PATH Hook
        shell: bash -el {0}
        run: |
          cat > rthook_win7.py << 'HOOK_EOF'
          import os
          import sys
          try:
              if hasattr(sys, '_MEIPASS'):
                  base_path = sys._MEIPASS
              else:
                  base_path = os.path.dirname(os.path.abspath(__file__))
              os.environ['PATH'] = base_path + ';' + os.environ.get('PATH', '')
          except Exception:
              pass
          HOOK_EOF

      - name: Create Encoding Hook
        shell: bash -el {0}
        run: |
          cat > rthook_encoding.py << 'HOOK_EOF'
          import sys
          import io
          try:
              if sys.stdout and sys.stdout.encoding != 'utf-8':
                  sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
              if sys.stderr and sys.stderr.encoding != 'utf-8':
                  sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')
          except Exception:
              pass
          HOOK_EOF

      - name: Build EXE
        shell: bash -el {0}
        run: |
          echo "===== Starting Build ====="
          pyinstaller --clean --log-level=INFO step2stl.spec
          
          echo "===== Build Output ====="
          ls -lh dist/
          # 你的 Spec 生成的文件夹名是 StepToStl_Folder
          ls -lh dist/StepToStl_Folder/ || true

      - name: Test executable
        shell: bash -el {0}
        env:
          PYTHONUTF8: 1
        run: |
          echo "===== Testing Executable ====="
          # 注意文件名大小写
          ./dist/StepToStl_Folder/StepToStl.exe --help || echo "Help test completed"

      - name: Pack Windows ZIP
        shell: bash -el {0}
        run: |
          cd dist
          # 压缩正确命名的文件夹
          7z a -tzip step2stl-windows-x64.zip StepToStl_Folder/

      - name: Upload Windows Folder
        uses: actions/upload-artifact@v4
        with:
          name: step2stl-windows-x64
          path: dist/StepToStl_Folder/

      - name: Upload Windows ZIP
        uses: actions/upload-artifact@v4
        with:
          name: step2stl-windows-x64-zip
          path: dist/step2stl-windows-x64.zip

  # macOS 部分保持不变（因为你已经成功了）
  build-macos-arm64:
    runs-on: macos-14
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Miniconda
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-update-conda: true
          python-version: ${{ env.PYTHON_MAC }}
          architecture: arm64
          channels: conda-forge, defaults
          channel-priority: flexible
      - name: Install Dependencies
        shell: bash -el {0}
        run: |
          conda install -y -c conda-forge ocp>=${{ env.OCP_VERSION_MAC }} trimesh numpy
          python -m pip install pyinstaller==${{ env.PYINSTALLER_VERSION }}
          python -c "from OCP.STEPCAFControl import STEPCAFControl_Reader; print('OCP import OK')"
      - name: Create Dummy Hooks
        shell: bash -el {0}
        run: |
          touch rthook_encoding.py
          touch rthook_win7.py
      - name: Build Binary
        shell: bash -el {0}
        run: |
          pyinstaller --clean --log-level=INFO step2stl.spec
      - name: Pack macOS ZIP
        shell: bash -el {0}
        run: |
          cd dist
          zip -r -9 step2stl-macos-arm64.zip StepToStl_Folder/
      - name: Upload macOS ARM64
        uses: actions/upload-artifact@v4
        with:
          name: step2stl-macos-arm64-zip
          path: dist/step2stl-macos-arm64.zip

  build-macos-x64:
    runs-on: macos-13
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Miniconda
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-update-conda: true
          python-version: ${{ env.PYTHON_MAC }}
          architecture: x64
          channels: conda-forge, defaults
          channel-priority: flexible
      - name: Install Dependencies
        shell: bash -el {0}
        run: |
          conda install -y -c conda-forge ocp>=${{ env.OCP_VERSION_MAC }} trimesh numpy
          python -m pip install pyinstaller==${{ env.PYINSTALLER_VERSION }}
          python -c "from OCP.STEPCAFControl import STEPCAFControl_Reader; print('OCP import OK')"
      - name: Create Dummy Hooks
        shell: bash -el {0}
        run: |
          touch rthook_encoding.py
          touch rthook_win7.py
      - name: Build Binary
        shell: bash -el {0}
        run: |
          pyinstaller --clean --log-level=INFO step2stl.spec
      - name: Pack macOS ZIP
        shell: bash -el {0}
        run: |
          cd dist
          zip -r -9 step2stl-macos-x64.zip StepToStl_Folder/
      - name: Upload macOS x64
        uses: actions/upload-artifact@v4
        with:
          name: step2stl-macos-x64-zip
          path: dist/step2stl-macos-x64.zip